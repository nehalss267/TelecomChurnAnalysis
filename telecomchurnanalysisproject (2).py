# -*- coding: utf-8 -*-
"""TelecomChurnAnalysisProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LgGCRsL6bXsRr4rNxXXvTNdTzs5HiEf0
"""

import pandas as pd
import numpy as np

df=pd.read_csv("/content/1730285168-TelecomCustomerChurn.csv")

df.head()

df.shape

df["Churn"].value_counts()
#to check if dataset is balanced or not-> accordingly ml technique is applied
#No is dominating so not balanced

df.info()

df.describe() #for numerical interpretations

df.isnull()

df.isnull().sum()

df.duplicated().sum()

list(df.columns)

y=df['Churn']
X=df.drop(['customerID','Churn'],axis=1)

X.head()

y.head()

y.value_counts()
#imbalanced dataset

from imblearn.over_sampling import RandomOverSampler
#imbalance learn

ros=RandomOverSampler()

X,y=ros.fit_resample(X,y)
#balances X and y

X.head()

y.value_counts()

#ordinal encoding
from sklearn.preprocessing import OrdinalEncoder

oe=OrdinalEncoder()

X=oe.fit_transform(X)

X

#train test split
from sklearn.model_selection import train_test_split

X_train,X_test,y_train,y_test=train_test_split(X,y,random_state=2529)

#select mode
from sklearn.ensemble import RandomForestClassifier

rfc=RandomForestClassifier()

rfc.fit(X_train,y_train)

y_pred=rfc.predict(X_test)

from sklearn.metrics import classification_report

print(classification_report(y_test,y_pred))

df.TotalCharges=pd.to_numeric(df.TotalCharges,errors='coerce')
df.isnull().sum()

df.dropna(inplace=True)

df.isnull().sum()

df_x=df.iloc[:,1:]

#Convert predictor value into binary
df_x['Churn'].replace(to_replace='Yes',value=1,inplace=True)
df_x['Churn'].replace(to_replace='No',value=0,inplace=True)

#One-hot encode categorical values
df_dummies=pd.get_dummies(df_x)
df_dummies.head()

import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick

sns.set_style("darkgrid")
single_color = "#2a9d8f"
dual_color = ['#e76f51', '#2a9d8f']
triple_color = ['#e76f51', '#2a9d8f','#264653']

#Correlation of "Churn" with other variables
fig=plt.figure(figsize=(8,10))
corr_plot=df_dummies.corr()['Churn']

head=corr_plot.sort_values(ascending=False)

sns.barplot(x=head.values, y=head.index, color=single_color)
plt.title("Variables correlation with churn")
plt.show()

fig=plt.figure(facecolor='white')
explode=[0,0.05]
ax=(df['Gender'].value_counts()*100.0/len(df)).plot.pie(autopct='%.1f%%',labels=df['Gender'],figsize=(5,5),fontsize=12,colors=dual_color,shadow=True,explode=explode)
ax.yaxis.set_major_formatter(mtick.PercentFormatter())
ax.set_ylabel('Gender',fontsize=12)
ax.set_title('Gender Distribution',fontsize=12)
plt.show()

fig=plt.figure(facecolor='white')
explode=[0,0.1]
ax=(df['SeniorCitizen'].value_counts()*100.0/len(df)).plot.pie(autopct='%.1f%%',labels=['No','yes'],figsize=(5,5),fontsize=12,colors=dual_color,shadow=True,explode=explode)
ax.yaxis.set_major_formatter(mtick.PercentFormatter())
ax.set_ylabel('Senior Citizens',fontsize=12)
ax.set_title('% of Senior Citizens',fontsize=12)
plt.show()

fig=plt.figure(facecolor='white')
df2=pd.melt(df,id_vars=['customerID'],value_vars=['Dependents','Partner'])
df3=df2.groupby(['variable','value']).count().unstack()
df3=df3*100/len(df)
ax=df3.loc[:,'customerID'].plot.bar(stacked=True,color=dual_color,figsize=(10,5),rot=0,width=0.2)

ax.yaxis.set_major_formatter(mtick.PercentFormatter())

ax.set_ylabel('% Customers',size = 14)
ax.set_xlabel('')
ax.set_title('% Customers with dependents and partners',size = 14)
ax.legend(loc = 'center',prop={'size':14})
for p in ax.patches:
    width, height = p.get_width(), p.get_height()
    x, y = p.get_xy()
    ax.annotate('{:.0f}%'.format(height), (p.get_x()+.25*width, p.get_y()+.4*height),
                color = 'white',
               weight = 'bold',
               size = 14)

"""Inference: Around half of the customers have a partner, and only about a third of the overall
customers have dependents.

"""

#Get Correlation of "Churn" with other variables:
sns.displot(data=df, x="Tenure",bins=int(180/5),height=5,aspect=2, color=single_color)
plt.title('Customer count by tenure')
plt.show()

"""Inference: Many consumers have only been with the telco service for just a month. There are also many cusstomers use their service for over 72 months. This
could be due to the fact that each customer has a different contract. As a result, depending on the contract, clients may find it simpler or more
difficult to stay with or quit the telecom firm.

"""

fig = plt.figure(figsize=(10,5),facecolor='white')
sns.countplot(x="Contract", data=df,palette=triple_color)
plt.show()

"""Inference:  Majority of consumers are on a month-to-month basis.
The 1 year and 2 year contracts have a near equal number of consumers. Just out of curiosity, let's see
the tenure of the customers based on their contract type.
"""

d = {'color': triple_color}
g = sns.FacetGrid(df, col="Contract",palette=triple_color,height=5, aspect=1,hue_kws=d)
g.map(sns.histplot, "Tenure",bins=int(180/5),color=single_color)
g.fig.subplots_adjust(top=0.8)
g.fig.suptitle('Tenure of each contracts')
plt.show()

"""Inference: Surprisingly, most monthly contracts are for 1-2 months, although two-year contracts are
typically for 70 months. This demonstrates that customers who sign a lengthier contract are more loyal to
the company and are more likely to stay with it for a longer time. This is also what we noticed in the churn
rate correlation chart previously
"""

df.columns.values

services = ['PhoneService','MultipleLines','InternetService','OnlineSecurity',
           'OnlineBackup','DeviceProtection','TechSupport','StreamingTV','StreamingMovies']
fig, axes = plt.subplots(nrows=3,ncols=3,figsize=(12,12),facecolor='white')
for i, item in enumerate(services):
    if i < 3:
        ax = df[item].value_counts().plot(kind='bar',ax=axes[i,0],rot=0,color=triple_color)
    elif i >=3 and i < 6:
        ax = df[item].value_counts().plot(kind='bar',ax=axes[i-3,1],rot=0,color=triple_color)
    elif i < 9:
        ax = df[item].value_counts().plot(kind='bar',ax=axes[i-6,2],rot=0,color=triple_color)
    ax.set_title(item)

fig=plt.figure(figsize=(10,5),facecolor='white')
plt.title('Correlation between monthly and total charges')
sns.scatterplot(data=df, x="MonthlyCharges", y="TotalCharges",hue='MonthlyCharges')
plt.show()

"""Inference: The monthly bill for a customer rises as well as the total charges.

"""

ax = (df['Churn'].value_counts()*100.0 /len(df))\
.plot(kind='bar',
      stacked = True,
      rot = 0,color = dual_color,
      figsize = (8,6)
     )
ax.yaxis.set_major_formatter(mtick.PercentFormatter())
ax.set_ylabel('% Customers',size = 14)
ax.set_xlabel('Churn',size = 14)
ax.set_title('Overall Churn Rate', size = 14)
# create a list to collect the plt.patches data
totals = []
# find the values and append to list
for i in ax.patches:
    totals.append(i.get_width())
# set individual bar lables using above list
total = sum(totals)
for i in ax.patches:
    # get_width pulls left or right; get_y pushes up or down
    ax.text(i.get_x()+.15, i.get_height()-4.0, \
            str(round((i.get_height()/total), 1))+'%',
            fontsize=12,
            color='white',
           weight = 'bold') # Removed 'size = 14' to resolve the TypeError

"""Inference:  Churn rate is 26.6%. We would expect a significant
majority of customers to not churn, hence the data is clearly skewed. This is wise to note during modelling
because skewness might results in a lot of false negatives.

"""

fig=plt.figure(figsize=(8,6),facecolor='white')
plt.title('Relationship between churn and tenure')
sns.boxplot(x = df['Churn'], y = df['Tenure'], hue = df['Churn'], palette=dual_color)
plt.show()

""" Inference: Customers who do not churn, as seen in the graph below, tends to stay with the telco operator for a longer period of time"""

contract_churn = df.groupby(['Contract','Churn']).size().unstack()
ax = (contract_churn.T*100.0 / contract_churn.T.sum())\
.T.plot(kind='bar',
        width = 0.3,
        stacked = True,
        rot = 0,
        figsize = (8,6),
        color = dual_color
       )
ax.yaxis.set_major_formatter(mtick.PercentFormatter())
ax.legend(loc='best',prop={'size':14},title = 'Churn')
ax.set_ylabel('% Customers',size = 14)
ax.set_title('Relationship between churn and contract type',size = 14)
# Code to add the data labels on the stacked bar chart
for p in ax.patches:
    width, height = p.get_width(), p.get_height()
    x, y = p.get_xy()
    ax.annotate('{:.0f}%'.format(height),
                (p.get_x()+.25*width, p.get_y()+.4*height),
                color = 'white',
                weight = 'bold',
                size = 14)

"""Inference: *Telco* users with month-to-month contracts tends to have
higher churn rate than the other contracts. This is quite similar from the results obtain in the correlation
between variables chart.
"""

seniority_churn = df.groupby(['SeniorCitizen','Churn']).size().unstack()
ax = (seniority_churn.T*100.0 / seniority_churn.T.sum())\
.T.plot(kind='bar',
        width = 0.2,
        stacked = True,
        rot = 0,
        figsize = (8,6),
        color = dual_color
       )
ax.yaxis.set_major_formatter(mtick.PercentFormatter())
ax.legend(loc='center',prop={'size':14},title = 'Churn')
ax.set_ylabel('% Customers')
ax.set_title('Relationship between churn and seniority level',size = 14)
# Code to add the data labels on the stacked bar chart
for p in ax.patches:
    width, height = p.get_width(), p.get_height()
    x, y = p.get_xy()
    ax.annotate('{:.0f}%'.format(height),
                (p.get_x()+.25*width, p.get_y()+.4*height),
                color = 'white',
                weight = 'bold',size =14)

"""Inference:  Telco users from the senior citizens group have nearly twice the
churn rate of younger citizens.
"""

fig = plt.figure(figsize=(10,5))
sns.kdeplot(df.MonthlyCharges[(df["Churn"] == 'No') ],
                color=dual_color[0],
                shade = True)
sns.kdeplot(df.MonthlyCharges[(df["Churn"] == 'Yes') ],
                color=dual_color[1],
                shade= True)
plt.legend(["Not Churn","Churn"],loc='upper right')
plt.ylabel('Density')
plt.xlabel('Monthly Charges')
plt.title('Distribution of monthly charges by churn')
plt.show()

"""Inference:  A high churn rate when the monthly charge is high and
lower when it is cheaper.
"""

fig = plt.figure(figsize=(10,5))
sns.kdeplot(df.TotalCharges[(df["Churn"] == 'No') ],
                color=dual_color[0],
                shade = True)
sns.kdeplot(df.TotalCharges[(df["Churn"] == 'Yes') ],
                color=dual_color[1],
                shade = True)
plt.legend(["Not Churn","Churn"],loc='upper right')
plt.ylabel('Density')
plt.xlabel('Total Charges')
plt.title('Distribution of total charges by churn')
plt.show()

"""Inference: The chart shows a higher chun rate on the lower values of total charges. Possibly the
customers chose to pay off their bill before stopping to use the telco service.
"""

# seperate label and features
y = df_dummies.Churn
X = df_dummies.drop('Churn', axis=1)

# From the dataset, we can see large differences between their ranges for each columns.
# Scaling all the variables to a range of 0 to 1
from sklearn.preprocessing import MinMaxScaler, StandardScaler
features = X.columns.values
scaler = StandardScaler()
scaler.fit(X)
X = pd.DataFrame(scaler.transform(X))
X.columns = features
features = X.columns##

# Split the data into training and testing sets
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=123)

# oversampling the data
from imblearn.over_sampling import SMOTE
oversample = SMOTE()
X, y = oversample.fit_resample(X, y)

# Split the oversampled data into training and testing sets
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=123)

# Import the models
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.neural_network import MLPClassifier

#Logistic Regression model
lr_model=LogisticRegression(C=10).fit(X_train,y_train)
#Support Vector Machine
svm_model=SVC(C=1.5,kernel='linear').fit(X_train,y_train)
# Neural Network
from sklearn.neural_network import MLPClassifier
nn_model=MLPClassifier(activation='logistic',
                       alpha=0.009,
                       validation_fraction=0.2).fit(X_train,y_train)
#print model scores
print('Logistic Regression Accuracy: {:.2f}%'.format(lr_model.score(X_test,y_test)*100))
print('Support Vector Machine Accuracy: {:.2f}%'.format(svm_model.score(X_test,y_test)*100))
print('Neural Network Accuracy: {:.2f}%'.format(nn_model.score(X_test,y_test)*100))

from sklearn.metrics import f1_score as f1
#make predictions
lr_pred = lr_model.predict(X_test)
svm_pred = svm_model.predict(X_test)
nn_pred = nn_model.predict(X_test)
#Print model's prediction f1 score
print('Logistic Regression Accuracy: {:.2f}%'.format(f1(y_test, lr_pred)*100))
print('Support Vector Machine Accuracy: {:.2f}%'.format(f1(y_test, svm_pred)*100))
print('Neural Network Accuracy: {:.2f}%'.format(f1(y_test, nn_pred)*100))

import numpy as np
import seaborn as sns
from sklearn.metrics import confusion_matrix
fig, axs = plt.subplots(nrows=1,ncols=3)
fig.set_size_inches(15, 4)
lr_cmat = confusion_matrix(y_test,lr_pred)
svm_cmat = confusion_matrix(y_test,svm_pred)
nn_cmat = confusion_matrix(y_test,nn_pred)
fig.suptitle("Prediction Model Confusion Matrix")
sns.heatmap(lr_cmat,annot=True,ax=axs[0],cmap=sns.dark_palette(triple_color[0]))
axs[0].set_title('Logistic Regression')
axs[0].set_xlabel('Actual')
axs[0].set_ylabel('Predicted')
sns.heatmap(svm_cmat,annot=True,ax=axs[1],cmap=sns.dark_palette(triple_color[0]))
axs[1].set_title('Support Vector machine')
axs[1].set_xlabel('Actual')
axs[1].set_ylabel('Predicted')
sns.heatmap(nn_cmat,annot=True,ax=axs[2],cmap=sns.dark_palette(triple_color[0]))
axs[2].set_title('Neural Network')
axs[2].set_xlabel('Actual')
axs[2].set_ylabel('Predicted')
plt.show()

"""Inference: From the confusion matrix, there are some false positives are significantly lower. I've
made another churn prediction model before this one and the false positives are way to high.
"""

from sklearn.metrics import classification_report
true = y_test
target_names = list(['no churn','churn'])
lr_clf_report = classification_report(true,
                                   lr_pred,
                                   target_names=target_names,
                                   output_dict=True)
svm_clf_report = classification_report(true,
                                   svm_pred,
                                   target_names=target_names,
                                   output_dict=True)
nn_clf_report = classification_report(true,
                                   nn_pred,
                                   target_names=target_names,
                                   output_dict=True)

fig, axs = plt.subplots(1,3)
fig.set_size_inches(15, 5)
fig.suptitle("Prediction Model Classification Report")
sns.heatmap(pd.DataFrame(lr_clf_report).iloc[:-1, :].T, annot=True,ax=axs[0],cmap=sns.dark_palette(triple_color[0]))
axs[0].set_title('Logistic Regression')
axs[0].tick_params(labelrotation=45,axis='y')
sns.heatmap(pd.DataFrame(svm_clf_report).iloc[:-1, :].T, annot=True,ax=axs[1],cmap=sns.dark_palette(triple_color[0]))
axs[1].set_title('Support Vector machine')
axs[1].tick_params(labelrotation=45,axis='y')
sns.heatmap(pd.DataFrame(nn_clf_report).iloc[:-1, :].T, annot=True,ax=axs[2],cmap=sns.dark_palette(triple_color[0]))
axs[2].set_title('Neural Network')
axs[2].tick_params(labelrotation=45,axis='y')
plt.show()

"""Inference: At a glance, we can see that our Support Vector Machine model works better than the other
two models by having better scores overall.

"""

fig = plt.figure(figsize=(8,5))
weights = pd.Series(svm_model.coef_[0],
                 index=X.columns.values)[:20]
head = weights.sort_values(ascending=False)
sns.barplot(x=head.values, y=head.index,color=single_color)
plt.title("SVM model's feature importance")
plt.show()

"""Inference: Some variables have a negative relationship with our anticipated variable (Churn), whereas
others have a positive relationship. A negative relationship indicates that the likelihood of churn
decreases as the variable is increased. Let's have a look at some of the more intriguing features:
The thing I found interesting is that telco users with Fiber Optic internet service are more likely to
churn rather than DSL. This is intriguing because, despite the fact that fibre optic services are
quicker, customers are more likely to churn as a result. I believe we need to go deeper to understand
why this is happening.
Quite similar to our correaltion between variables plot in our EDA, we can see that tenure and two
year contracts, and monthly charges contributed to lower rates of churn. Having longer contracts
possibly cause increased loyalty from the telco customers. Monthly charges cause lower churn rates
possibly the telco users are in a country where salary are mostly given monthly and they have less
stress when paying telco bills since they currently have money for it.
"""

!pip install gradio

print(list(features))

def predict_churn(
    senior_citizen_input,
    tenure_input,
    monthly_charges_input,
    total_charges_input,
    gender_input,
    partner_input,
    dependents_input,
    phone_service_input,
    multiple_lines_input,
    internet_service_input,
    online_security_input,
    online_backup_input,
    device_protection_input,
    tech_support_input,
    streaming_tv_input,
    streaming_movies_input,
    contract_input,
    paperless_billing_input,
    payment_method_input,
):
    # initialize all features as 0
    input_dict = {col: 0 for col in features}

    # numeric / binary base columns
    input_dict["SeniorCitizen"] = 1 if senior_citizen_input == "Yes" else 0
    input_dict["Tenure"] = tenure_input
    input_dict["MonthlyCharges"] = monthly_charges_input
    input_dict["TotalCharges"] = total_charges_input

    # ========== ONE‑HOT USING YOUR EXACT COLUMN NAMES ==========

    # Gender_Female, Gender_Male
    if gender_input == "Female":
        input_dict["Gender_Female"] = 1
    else:
        input_dict["Gender_Male"] = 1

    # Partner_No, Partner_Yes
    if partner_input == "Yes":
        input_dict["Partner_Yes"] = 1
    else:
        input_dict["Partner_No"] = 1

    # Dependents_No, Dependents_Yes
    if dependents_input == "Yes":
        input_dict["Dependents_Yes"] = 1
    else:
        input_dict["Dependents_No"] = 1

    # PhoneService_No, PhoneService_Yes
    if phone_service_input == "Yes":
        input_dict["PhoneService_Yes"] = 1
    else:
        input_dict["PhoneService_No"] = 1

    # MultipleLines_No, MultipleLines_Yes
    if multiple_lines_input == "Yes":
        input_dict["MultipleLines_Yes"] = 1
    elif multiple_lines_input == "No":
        input_dict["MultipleLines_No"] = 1
    # "No phone service" -> both stay 0

    # InternetService_DSL, InternetService_Fiber optic, InternetService_No
    if internet_service_input == "DSL":
        input_dict["InternetService_DSL"] = 1
    elif internet_service_input == "Fiber optic":
        input_dict["InternetService_Fiber optic"] = 1
    else:
        input_dict["InternetService_No"] = 1

    # OnlineSecurity_No, OnlineSecurity_Yes
    if online_security_input == "Yes":
        input_dict["OnlineSecurity_Yes"] = 1
    elif online_security_input == "No":
        input_dict["OnlineSecurity_No"] = 1

    # OnlineBackup_No, OnlineBackup_Yes
    if online_backup_input == "Yes":
        input_dict["OnlineBackup_Yes"] = 1
    elif online_backup_input == "No":
        input_dict["OnlineBackup_No"] = 1

    # DeviceProtection_No, DeviceProtection_Yes
    if device_protection_input == "Yes":
        input_dict["DeviceProtection_Yes"] = 1
    elif device_protection_input == "No":
        input_dict["DeviceProtection_No"] = 1

    # TechSupport_No, TechSupport_Yes
    if tech_support_input == "Yes":
        input_dict["TechSupport_Yes"] = 1
    elif tech_support_input == "No":
        input_dict["TechSupport_No"] = 1

    # StreamingTV_No, StreamingTV_Yes
    if streaming_tv_input == "Yes":
        input_dict["StreamingTV_Yes"] = 1
    elif streaming_tv_input == "No":
        input_dict["StreamingTV_No"] = 1

    # StreamingMovies_No, StreamingMovies_Yes
    if streaming_movies_input == "Yes":
        input_dict["StreamingMovies_Yes"] = 1
    elif streaming_movies_input == "No":
        input_dict["StreamingMovies_No"] = 1

    # Contract_Monthly, Contract_One year, Contract_Two year
    if contract_input == "Monthly":
        input_dict["Contract_Monthly"] = 1
    elif contract_input == "One year":
        input_dict["Contract_One year"] = 1
    else:
        input_dict["Contract_Two year"] = 1

    # PaperlessBilling_No, PaperlessBilling_Yes
    if paperless_billing_input == "Yes":
        input_dict["PaperlessBilling_Yes"] = 1
    else:
        input_dict["PaperlessBilling_No"] = 1

    # PaymentMethod_Bank transfer (automatic),
    # PaymentMethod_Credit card (automatic),
    # PaymentMethod_Manual   <-- your third category
    if payment_method_input == "Bank transfer (automatic)":
        input_dict["PaymentMethod_Bank transfer (automatic)"] = 1
    elif payment_method_input == "Credit card (automatic)":
        input_dict["PaymentMethod_Credit card (automatic)"] = 1
    else:
        input_dict["PaymentMethod_Manual"] = 1

    # DataFrame with same column order
    input_df = pd.DataFrame([input_dict], columns=features)

    # IMPORTANT: scale ALL columns because scaler was fit on X (all features)
    # input_df[:] = scaler.transform(input_df)

    # predict with your trained SVM
    pred = svm_model.predict(input_df)[0]

    if pred == 1:
        return "Prediction: Customer is likely to CHURN"
    else:
        return "Prediction: Customer is likely to STAY"

# # Example: non‑senior, 12 months, medium charges, typical services
# test_result = predict_churn(
#     senior_citizen_input="No",          # 1
#     tenure_input=12,                    # 2
#     monthly_charges_input=70.0,         # 3
#     total_charges_input=800.0,          # 4
#     gender_input="Female",              # 5
#     partner_input="Yes",                # 6
#     dependents_input="No",              # 7
#     phone_service_input="Yes",          # 8
#     multiple_lines_input="No",          # 9
#     internet_service_input="Fiber optic",   # 10
#     online_security_input="No",         # 11
#     online_backup_input="Yes",          # 12
#     device_protection_input="No",       # 13
#     tech_support_input="No",            # 14
#     streaming_tv_input="Yes",           # 15
#     streaming_movies_input="Yes",       # 16
#     contract_input="Monthly",           # 17
#     paperless_billing_input="Yes",      # 18
#     payment_method_input="Bank transfer (automatic)"  # 19
# )

# print(test_result)

inputs = [
    gr.Radio(["No", "Yes"], label="Senior Citizen", value="No"),
    gr.Slider(1, 72, step=1, label="Tenure (months)", value=12),
    gr.Number(label="Monthly Charges", value=50.0),
    gr.Number(label="Total Charges", value=600.0),
    gr.Radio(["Female", "Male"], label="Gender", value="Female"),
    gr.Radio(["Yes", "No"], label="Partner", value="No"),
    gr.Radio(["Yes", "No"], label="Dependents", value="No"),
    gr.Radio(["Yes", "No"], label="Phone Service", value="Yes"),
    gr.Radio(["No phone service", "No", "Yes"], label="Multiple Lines", value="No"),
    gr.Radio(["DSL", "Fiber optic", "No"], label="Internet Service", value="DSL"),
    gr.Radio(["No internet service", "No", "Yes"], label="Online Security", value="No"),
    gr.Radio(["No internet service", "No", "Yes"], label="Online Backup", value="No"),
    gr.Radio(["No internet service", "No", "Yes"], label="Device Protection", value="No"),
    gr.Radio(["No internet service", "No", "Yes"], label="Tech Support", value="No"),
    gr.Radio(["No internet service", "No", "Yes"], label="Streaming TV", value="No"),
    gr.Radio(["No internet service", "No", "Yes"], label="Streaming Movies", value="No"),
    gr.Radio(["Monthly", "One year", "Two year"], label="Contract", value="Monthly"),
    gr.Radio(["Yes", "No"], label="Paperless Billing", value="Yes"),
    gr.Radio(
        ["Electronic check", "Mailed check", "Bank transfer (automatic)", "Credit card (automatic)"],
        label="Payment Method",
        value="Electronic check",
    ),
]

import gradio as gr
output = gr.Textbox(label="Churn Prediction Result")

demo = gr.Interface(
    fn=predict_churn,
    inputs=inputs,
    outputs=output,
    title="Telecom Customer Churn Prediction",
    description="Change the parameters and click Submit to see churn prediction.",
)

demo.launch(debug=True)

